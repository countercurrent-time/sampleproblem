我除了 `getvalbyrank`（即代码中的 `find()`），其他函数基于 `splay(p, v)`，`split(p, v)` 和 `merge` 的 Splay 版本。

`splay(p, v)` 会将以 `p` 为根的子树中权值为 `v` 的节点旋转到 `p` 的位置。

`split(p, v)` 会将以 `p` 为根的子树分为两部分，第一部分的节点是权值小于等于 `v` 的节点。

我们继续讨论如何在这种形式的伸展树中消除多个相同权值的独立节点带来的 `splay(), split()` 等操作的歧义性，并把所有的权值等于 `v` 的节点分到同一边（这里讨论分到第一部分的情况）。

先考虑相同权值的节点可能的位置分布：对于任意一个节点，它的前驱的位置和后继的位置都可能是与它权值相同的节点的位置。对任意与它权值相等的节点也如此。

首先考虑将第三种形式的伸展树的 `cmp(p, v)` 函数移植过来，其他部分大体不变。`cmp`（或 `cmpv`）用来判断 `splay` 的方向，返回 -1 代表对这个节点 splay，返回 0 或 1 代表向下寻找要被 splay 的节点的方向：

```cpp
int cmpv(int p, int v) {
  if (val[p] == v || p == 0 || ch[p][val[p] < v]) return -1;
  return val[p] < v;
}
```

由上面的相同权值节点的位置分布我们得知：我们使用这个版本的 `cmpv` 找到的第一个权值等于 `v` 的节点一定是离根最近的权值等于 `v` 的节点，而且所有的其它权值等于 `v` 的节点都在以此节点为根的子树中，因为如果不是这样，则所有节点的最近公共祖先的权值不等于 `v`，且 `v` 既大于又小于最近公共祖先的权值，矛盾。

但是如果要通过 `splay` 和 `split` 将所有的权值等于 `v` 的节点分裂到同一边（这里讨论的是分裂到左边），必须要找到这样的权值等于 `v` 的节点，使得它的后继的位置上的节点权值不等于 `v`。但是根据上面的分析，我们实际找到的节点不是需要找到的节点。

我们可以通过增加一个特定规则的寻找函数来找到上述节点。这会增加一定的复杂度，且不利于递归 `splay()` 函数的设计。

也可以从新的基础开始，找到 `v` 的后继，确定 `v` 的后继的排名，然后找到 `v` 的后继排名减 $1$ 的排名的节点。但这样远离了根据权值查找节点并同时完成伸展操作的内核。

然后我们考虑 FhqTreap 的方法：它的按照权值分裂的版本的 `split` 函数和第三种形式的伸展树的 `rank` 函数一样，遇到权值与所查询权值相同的节点也会继续向下分裂。所以我们调整 `cmpv()` 为类似的形式：

```cpp
int cmpv(int p, int v) {
  if (p == 0 || ch[p][val[p] <= v] == 0) return -1;
  return val[p] <= v;
}
```

但伸展树和 FhqTreap 的分裂方法有本质区别。FhqTreap 的 `split()` 本身能够精确地分裂树，不具有歧义性；而伸展树的 `split()` 基于 `splay()`，只会对一个节点 `splay()`，如果像这样一味向下查找可能会导致两种情况：

1. 找到权值为 `v` 的不唯一的节点；
2. 找到 `v` 的不唯一的后继。

综上，我们可以讨论出找到这样的权值等于 `v` 的节点，使得它的后继的位置上的节点权值不等于 `v` 的方法：

先使用上述 `cmpv` 找到所有权值为 `v` 的节点的最近公共祖先，设其为 p；
1. p 是要找的节点；
2. p 不是要找的节点；
   则一直向右，如果当前节点的右儿子权值不是 `v` 就从其右儿子一直向左，直到找到第一个权值为 `v` 的节点，如果找不到权值为 `v` 的节点，则前面的当前节点就是要找的节点。

代码实现上也很简单，只需要在上述 `cmpv` 的基础上，`rotate()` 中判断要被旋转上来的节点是否权值为 `v` 就可以了。

不过由于插入时会用不存在的权值调用 `split()` ，所以小于 `v` 的权值的节点也应该被旋转上来。

还由于 `splay()` 旋转的特点（双旋），不仅要对当前的要被旋转上来的节点作判断，还要对实际将要被旋转上来的节点做相似的判断。具体见代码：

```cpp
void rotate(int& p, int d, int v) {
  int q = ch[p][d];
  if (val[q] <= v || (ch[q][d] != 0 && val[ch[q][d]] <= v)) { // DONE
    link(p, d, ch[q][d ^ 1]);
    link(q, d ^ 1, p);
    p = q;
  }
}
```

不过这样有一个缺点：当 `v` 比树中所有节点的权值都小时，`splay()` 将不会旋转。这样的情况常出现在 `rank()` 查询树中最小的权值 `v` 的排名时，用 `v - 1` 调用 `splay()`。在极端情况下，伸展树长期是一条链，而 `rank()` 中的 `splay()` 函数需要频繁调用并一直搜索到链的末端。时间复杂度被卡成 $O(n ^ 2)$。

尽管这样不很合规范，但是我确实已经花了很多时间在这上面了，所以我们充分发扬人类集体智慧。目前我能想到的最简单的办法是：`rank()` 时随机 `splay()` 一个节点。

```cpp
int rank(int v) {
  pair<int, int> p = split(root, v - 1);
  int ret = size[p.first] + 1;
  root = merge(p.first, p.second);
  find(root, rand() % size[root] + 1);
  return ret;
}
```

