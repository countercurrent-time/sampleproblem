以 `insert(v)` 为基础的伸展树。

与 `std.cpp` 相比还使用了 `link(p, f, d = 0)` 连接两个节点。其关键在于能够维护伸展树的所有有维护必要的信息（调用 `push_up()` 并维护 `root`），使所有需要修改伸展树的操作都可以调用它来实现而不破坏树的结构。

注意其中的 `get(p)`，通常它有两种写法：

```cpp
bool get(int p) { return val[fa[p]] < val[p]; }
```

```cpp
bool get(int p) { return p == ch[fa[p]][1]; }
```

第一种写法在 `fa[p] == 0` 或者 `p == 0` 时会失效，然而 `fa[x] == 0` 时不需要 `get(p)`，所以需要注意的是 `p == 0` 的情况，需要手动确定节点在其祖先节点的哪一边。

由于当前节点是否为 `0` 一般会被考虑到，所以需要手动确定方向的一般是连接 `p` 的父亲和子节点时，这会出现在 `rotate()` 和 `del()` 中。

第二种写法在两节点尚未确定父子关系会失效，然而大部分调用 `get(p)` 的情况是 `link(p, f, d)`，用以判断 `p` 是 `f` 的左或右子节点时。

所以第一种 `get(p)` 比第二种的使用范围更广。

